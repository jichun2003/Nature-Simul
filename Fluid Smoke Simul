import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.widgets import Button, Slider

# ---- Simulation Constants ----
height, width = 80, 200
u0 = 0.1
viscosity = 0.02
omega = 1 / (3 * viscosity + 0.5)

four9ths = 4.0 / 9.0
one9th = 1.0 / 9.0
one36th = 1.0 / 36.0

barrier_x = width // 4

# ---- Initial Conditions ----
def reset_simulation():
    global n0, nN, nS, nE, nW, nNE, nNW, nSE, nSW
    global rho, ux, uy, barrier, barrierN, barrierS, barrierE, barrierW
    global barrierNE, barrierNW, barrierSE, barrierSW, density

    n0 = four9ths * (np.ones((height, width)) - 1.5 * u0 ** 2)
    nN = one9th * (np.ones((height, width)) - 1.5 * u0 ** 2)
    nS = one9th * (np.ones((height, width)) - 1.5 * u0 ** 2)
    nE = one9th * (np.ones((height, width)) + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nW = one9th * (np.ones((height, width)) - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nNE = one36th * (np.ones((height, width)) + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nSE = one36th * (np.ones((height, width)) + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nNW = one36th * (np.ones((height, width)) - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nSW = one36th * (np.ones((height, width)) - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)

    rho = n0 + nN + nS + nE + nW + nNE + nSE + nNW + nSW
    ux = (nE + nNE + nSE - nW - nNW - nSW) / rho
    uy = (nN + nNE + nNW - nS - nSE - nSW) / rho

    barrier = np.zeros((height, width), bool)
    barrier[(height // 2) - 8:(height // 2) + 8, barrier_x] = True
    barrierN = np.roll(barrier, 1, axis=0)
    barrierS = np.roll(barrier, -1, axis=0)
    barrierE = np.roll(barrier, 1, axis=1)
    barrierW = np.roll(barrier, -1, axis=1)
    barrierNE = np.roll(barrierN, 1, axis=1)
    barrierNW = np.roll(barrierN, -1, axis=1)
    barrierSE = np.roll(barrierS, 1, axis=1)
    barrierSW = np.roll(barrierS, -1, axis=1)

    density = np.zeros((height, width))
    density[:, 5] = 1.0

reset_simulation()

# ---- Simulation Step Functions ----
def stream():
    global nN, nS, nE, nW, nNE, nNW, nSE, nSW
    nN = np.roll(nN, 1, axis=0)
    nNE = np.roll(nNE, 1, axis=0)
    nNW = np.roll(nNW, 1, axis=0)
    nS = np.roll(nS, -1, axis=0)
    nSE = np.roll(nSE, -1, axis=0)
    nSW = np.roll(nSW, -1, axis=0)
    nE = np.roll(nE, 1, axis=1)
    nNE = np.roll(nNE, 1, axis=1)
    nSE = np.roll(nSE, 1, axis=1)
    nW = np.roll(nW, -1, axis=1)
    nNW = np.roll(nNW, -1, axis=1)
    nSW = np.roll(nSW, -1, axis=1)

    nN[barrierN] = nS[barrier]
    nS[barrierS] = nN[barrier]
    nE[barrierE] = nW[barrier]
    nW[barrierW] = nE[barrier]
    nNE[barrierNE] = nSW[barrier]
    nNW[barrierNW] = nSE[barrier]
    nSE[barrierSE] = nNW[barrier]
    nSW[barrierSW] = nNE[barrier]

def collide():
    global rho, ux, uy, n0, nN, nS, nE, nW, nNE, nNW, nSE, nSW
    rho = n0 + nN + nS + nE + nW + nNE + nSE + nNW + nSW
    ux = (nE + nNE + nSE - nW - nNW - nSW) / rho
    uy = (nN + nNE + nNW - nS - nSE - nSW) / rho

    ux2, uy2 = ux**2, uy**2
    u2 = ux2 + uy2
    omu215 = 1 - 1.5 * u2
    uxuy = ux * uy

    n0 = (1 - omega) * n0 + omega * four9ths * rho * omu215
    nN = (1 - omega) * nN + omega * one9th * rho * (omu215 + 3 * uy + 4.5 * uy2)
    nS = (1 - omega) * nS + omega * one9th * rho * (omu215 - 3 * uy + 4.5 * uy2)
    nE = (1 - omega) * nE + omega * one9th * rho * (omu215 + 3 * ux + 4.5 * ux2)
    nW = (1 - omega) * nW + omega * one9th * rho * (omu215 - 3 * ux + 4.5 * ux2)
    nNE = (1 - omega) * nNE + omega * one36th * rho * (omu215 + 3 * (ux + uy) + 4.5 * (u2 + 2 * uxuy))
    nNW = (1 - omega) * nNW + omega * one36th * rho * (omu215 + 3 * (-ux + uy) + 4.5 * (u2 - 2 * uxuy))
    nSE = (1 - omega) * nSE + omega * one36th * rho * (omu215 + 3 * (ux - uy) + 4.5 * (u2 - 2 * uxuy))
    nSW = (1 - omega) * nSW + omega * one36th * rho * (omu215 + 3 * (-ux - uy) + 4.5 * (u2 + 2 * uxuy))

    nE[:,0] = one9th * (1 + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nW[:,0] = one9th * (1 - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nNE[:,0] = one36th * (1 + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nSE[:,0] = one36th * (1 + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nNW[:,0] = one36th * (1 - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)
    nSW[:,0] = one36th * (1 - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2)

def advect():
    global density
    new_density = np.copy(density)
    for i in range(1, height-1):
        for j in range(1, width-1):
            x = j - ux[i,j]
            y = i - uy[i,j]
            i0, i1 = int(y), int(y+1)
            j0, j1 = int(x), int(x+1)
            if 0 <= i0 < height and 0 <= i1 < height and 0 <= j0 < width and 0 <= j1 < width:
                new_density[i,j] = 0.25 * (density[i0,j0] + density[i0,j1] + density[i1,j0] + density[i1,j1])
    density = new_density * 0.99

def curl(ux, uy):
    return np.roll(uy,-1,axis=1) - np.roll(uy,1,axis=1) - np.roll(ux,-1,axis=0) + np.roll(ux,1,axis=0)

# ---- GUI Setup ----
fig = plt.figure(figsize=(9,4.5))
ax_img = plt.axes([0.05, 0.3, 0.9, 0.65])
fluid_img = ax_img.imshow(curl(ux, uy), origin='lower', cmap='bwr', norm=plt.Normalize(-0.1, 0.1))
smoke_img = ax_img.imshow(density, origin='lower', cmap='gray', alpha=0.7)
ax_img.set_xticks([]); ax_img.set_yticks([])
barrier_img = ax_img.imshow(np.dstack([np.zeros((height,width))]*3 + [255*barrier]), origin='lower', interpolation='none')

ax_run = plt.axes([0.08, 0.16, 0.1, 0.05])
btn_run = Button(ax_run, 'â–¶ Run')
ax_step = plt.axes([0.19, 0.16, 0.1, 0.05])
btn_step = Button(ax_step, 'Step')
ax_reset = plt.axes([0.30, 0.16, 0.1, 0.05])
btn_reset = Button(ax_reset, 'Reset')
ax_slider_u0 = plt.axes([0.5, 0.18, 0.4, 0.03])
slider_u0 = Slider(ax_slider_u0, 'Flow speed', 0.01, 0.3, valinit=u0)
ax_slider_visc = plt.axes([0.5, 0.12, 0.4, 0.03])
slider_visc = Slider(ax_slider_visc, 'Viscosity', 0.005, 0.1, valinit=viscosity)
ax_slider_barrier = plt.axes([0.5, 0.06, 0.4, 0.03])
slider_barrier = Slider(ax_slider_barrier, 'Barrier X', 5, width - 5, valinit=barrier_x, valstep=1)

is_running = False
def toggle_run(event):
    global is_running
    is_running = not is_running

def step_once(event):
    stream(); collide(); advect()
    fluid_img.set_array(curl(ux, uy))
    smoke_img.set_array(density)
    fig.canvas.draw_idle()

def reset_all(event):
    reset_simulation()
    fluid_img.set_array(curl(ux, uy))
    smoke_img.set_array(density)
    barrier_img.set_data(np.dstack([np.zeros((height,width))]*3 + [255*barrier]))
    fig.canvas.draw_idle()

def update_u0(val):
    global u0
    u0 = val

def update_viscosity(val):
    global viscosity, omega
    viscosity = val
    omega = 1 / (3 * viscosity + 0.5)

def update_barrier_x(val):
    global barrier_x
    barrier_x = int(val)
    reset_simulation()
    fluid_img.set_array(curl(ux, uy))
    smoke_img.set_array(density)
    barrier_img.set_data(np.dstack([np.zeros((height,width))]*3 + [255*barrier]))
    fig.canvas.draw_idle()

btn_run.on_clicked(toggle_run)
btn_step.on_clicked(step_once)
btn_reset.on_clicked(reset_all)
slider_u0.on_changed(update_u0)
slider_visc.on_changed(update_viscosity)
slider_barrier.on_changed(update_barrier_x)

def update_frame(frame):
    if is_running:
        for _ in range(10):
            stream(); collide(); advect()
        fluid_img.set_array(curl(ux, uy))
        smoke_img.set_array(density)
    return (fluid_img, smoke_img)

ani = animation.FuncAnimation(fig, update_frame, interval=30, blit=False)
plt.show()
